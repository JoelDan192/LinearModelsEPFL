?replicate
g = 9.8 ## meters per second
h0 = 56.67
v0 = 0
n = 25
tt = seq(0,3.4,len=n) ##time in secs, t is a base function
y = h0 + v0 *tt - 0.5* g*tt^2 + rnorm(n,sd=1)
X = cbind(1,tt,tt^2)
A = solve(crossprod(X))%*%t(X)
-2 * (A %*% y) [3]
LSE <- function(){
y = h0 + v0 *tt - 0.5* g*tt^2 + rnorm(n,sd=1)
X = cbind(1,tt,tt^2)
A = solve(crossprod(X))%*%t(X)
-2 * (A %*% y) [3]
}
LSE()
LSE()
LSE()
LSE()
LSE()
LSE()
LSE()
LSE()
LSE()
LSE()
LSE()
LSE()
LSE()
replicate(2,LSE())
test <- replicate(100000, LSE())
head(test)
summary(test)
sqrt(var(test))
library(UsingR)
x = father.son$fheight
y = father.son$sheight
n = length(y)
N = 50
index = sample(n,N)
sampledat = father.son[index,]
x = sampledat$fheight
y = sampledat$sheight
betahat = lm(y~x)$coef
betahat
x
y
plot(x,y)
plot(y,x)
fun <- function(){
N = 50
index = sample(n,N)
sampledat = father.son[index,]
x = sampledat$fheight
y = sampledat$sheight
betahat = lm(y~x)$coef
betahat$x
}
fun()
fun <- function(){
N = 50
index = sample(n,N)
sampledat = father.son[index,]
x = sampledat$fheight
y = sampledat$sheight
betahat = lm(y~x)$coef
betahat[2]
}
fun()
fun()
fun()
fun()
fun()
fun()
fun()
fun()
fun()
fun()
fun()
fun()
fun()
fun()
test <- replicate(10000,fun())
head(test)
fun <- function(){
N = 50
index = sample(n,N)
sampledat = father.son[index,]
x = sampledat$fheight
y = sampledat$sheight
betahat = lm(y~x)$coef
betahat[2]
}
test <- replicate(10000,fun())
sqrt(var(test))
cov <- mean( (y - mean(y))*(x-mean(x) ) )
cov
library(UsingR)
x = father.son$fheight
y = father.son$sheight
n = length(y)
N = 50
set.seed(1)
index = sample(n,N)
sampledat = father.son[index,]
x = sampledat$fheight
y = sampledat$sheight
betahat = lm(y~x)$coef
SE(betahat) = sqrt(var(betahat))
var(betahat) = sigma^2 (X^T X)^-1
x
y
n
y
index
sampledat
x
father.son
betahat = lm(y~x)$coef
betahat
y
fit = lm(y ~ x)
fit$fitted.values
head(fit$fitted.values)
y-fit$fitted.values
sum(y-fit$fitted.values)
unlist(fit$fitted.values)
fit$fitted.values[1]
fit$fitted.values[[1]
fit$fitted.values[[1]
fit$fitted.values[[1]]
length(fit$fitted.values)
listToVector <- function(l){
len <- length(l)
vec <- c()
for i in (1:len) {
vec <- c(vec,l[[i]])
}
}
listToVector <- function(l) {
len <- length(l)
vec <- c()
for (i in 1:len) {
vec <- c(vec,l[[i]])
}
}
listToVector <- function(l) {
len <- length(l)
vec <- c()
for (i in 1:len) {
vec <- c(vec,l[[i]])
}
vec
}
listToVector(fit$fitted.values)
Y_at <- listToVector(fit$fitted.values)
r <- y-Y_at
r
sum(r^2)
SSR <- sum(r^2)
sigma2 = SSR / 48
X = cbind(rep(1,N), x)
solve(t(X) %*% X)
d <- diag(solve(t(X) %*% X))
d
solve(t(X) %*% X)
sigma2
d <- diag(solve(t(X) %*% X))
estVar <- sigma2 * d
estVar
sqrt(estVar)
x <- c(1,1,2,2)
f <- formula(~ x)
f
model.matrix(f)
x <- c(1,1,2,2,3,3)
model.matrix(~ x)
x <- factor(c(1,1,2,2,3,3))
model.matrix(~ x)
model.matrix(~ x + y)
x <- factor(c(1,1,2,2,3,3))
y <- factor(c('a','a','b','b','a','a','b','b'))
model.matrix(~ x + y)
x <- factor(c(1,1,1,1,2,2,2,2))
y <- factor(c('a','a','b','b','a','a','b','b'))
model.matrix(~ x + y)
model.matrix(~ x + y + x:y)
model.matrix(~ day + condition)
day <- factor(c('A','B','C'))
condition <- factor(c('treated','control'))
model.matrix(~ day + condition)
model.matrix(~ condition)
model.matrix(~ day)
model.matrix(~ A + B + C + control + treated)
day <- factor(c('A','B','C'))
condition <- factor(c('treated','control'))
model.matrix(~ A + B + C + control + treated)
model.matrix(~ day + condition)
model.matrix(~ condition)
day <- factor(c('A','B','C'))
condition <- factor(c('treated','control'))
model.matrix(~ day + condition)
day <- factor(c('A','B','C','A','B','C'))
condition <- factor(c('treated','treated','treated','control','control','control'))
model.matrix(~ day + condition)
url <- "https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleMiceWeights.csv"
url <- "https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleMiceWeights.csv"
filename <- "femaleMiceWeights.csv"
library(download)
if(!file.exists(filename)) download(url,filename)
dat <- read.csv(filename)
url <- "https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleMiceWeights.csv"
filename <- "femaleMiceWeights.csv"
library(downloader)
if(!file.exists(filename)) download(url,filename)
dat <- read.csv(filename)
install(downloader)
install.packages(downloader)
install.packages("downloader")
url <- "https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleMiceWeights.csv"
filename <- "femaleMiceWeights.csv"
library(downloader)
if(!file.exists(filename)) download(url,filename)
dat <- read.csv(filename)
dat
stripchart(dat$Bodyweight ~ dat$Diet,vertical = TRUE, method="jitter", main = "Bodyweight over Diet")
stripchart(dat$Bodyweight ~ dat$Diet,vertical = TRUE, method="jitter", main = "Bodyweight over Diet")
levels(dat$Diet)
levels(dat$Diet)
X <- model.matrix(~ Diet, data=dat)
X
colnames(X)
dat$Diet <- relevel(dat$Diet, ref ='hf')
dat$Diet
dat$Diet <- relevel(dat$Diet, ref ='hf')
X <- model.matrix(~ Diet, data=dat)
X
dat$Diet <- relevel(dat$Diet, ref ='chow')
X <- model.matrix(~ Diet, data=dat)
X
fit <- lm(Bodyweight ~ Diet, data=dat)  # the Y here is the Bodyweight, and we want to model it over the Diet
summary(fit)
(coefs <- coef(fit))
Y <- dat$Bodyweight
X <- model.matrix(~ Diet, data=dat)
solve(t(X) %*% X) %*% t(X) %*% Y
s <- split(dat$Bodyweight, dat$Diet)
s
class(s)
mean(s[["chow"]])
mean(s[["hf"]]) - mean(s[["chow"]])
stripchart(dat$Bodyweight ~ dat$Diet, vertical=TRUE, method="jitter", main="Bodyweight over Diet",
ylim=c(0,40),xlim=c(0,3))
install.package("RColorBrewer")
install.packages("RColorBrewer")
stripchart(dat$Bodyweight ~ dat$Diet, vertical=TRUE, method="jitter", main="Bodyweight over Diet",
ylim=c(0,40),xlim=c(0,3))
a <- -0.25
lgth <- .1
library(RColorBrewer)
cols <- brewer.pal(3,"Dark2")
abline(h=0)
coefs[1]
arrows(1+a,0, 1+a, coefs[1])
arrows(1+a,0, 1+a, coefs[1],lwd=3,col=cols[1], length=lgth)
abline(h=coefs[1],col=cols[1])
arrows(2+a,coefs[1], 2+a, coefs[1]+coefs[2],lwd=3,col=cols[2], length=lgth)
abline(h=coefs[1]+coefs[2],col=cols[2])
summary(fit)$coefficients
nx <- 5
ny <- 7
X = cbind(rep(1,nx + ny),rep(c(0,1),c(nx, ny)))
X
t(X)*X
t(X)%*%X
sex <- factor(rep(c("female","male"),each=4))
trt <- factor(c("A","A","B","B","C","C","D","D"))
X <- model.matrix( ~ sex + trt)
qr(X)$rank
Y <- 1:8
makeYstar <- function(a,b) Y - X[,2] * a - X[,5] * b
fitTheRest <- function(a,b) {
Ystar <- makeYstar(a,b)
Xrest <- X[,-c(2,5)]
betarest <- solve(t(Xrest) %*% Xrest) %*% t(Xrest) %*% Ystar
residuals <- Ystar - Xrest %*% betarest
sum(residuals^2)
}
fitTheRest(1,2)
outer(1:3,1:3,`*`)
min(outer(-2:8,-2:8,Vectorize(fitTheRest)))
library(rafalib)
imagemat(outer(-2:8,-2:8,Vectorize(fitTheRest)))
fit <- lm(friction ~ type + leg, data=spider)
betahat <- coef(fit)
Y <- matrix(spider$friction, ncol=1)
X <- model.matrix(~ type + leg, data=spider)
QR <- qr(X)
Q <- qr.Q( QR )
Q[1,1]
R <- qr.R( QR )
R[1,1]
t(Q)%*%Y
solve(R)%*%t(Q)%*%Y
q()
library(faraway)
install.packages(faraway)
install.packages(faraway)
install.packages("faraway")
install.packages("faraway")
data(pima)
pima
library(faraway)
data(pima)
pima
summary(pima)
sort(diastolic)
attach(pima)
sort(diastolic)
diastolic[diastolic==0]
pregnant[pregnant==0] <- NA
glucose[glucose==0] <- NA
diastolic[diastolic==0] <- NA
triceps[triceps==0] <- NA
insulin[insulin==0] <- NA
diabetes[diabetes==0] <- NA
age[age==0] <- NA
summary(pima)
y <- c(1,2,3,0,1,5)
y
x <- c(1,0,2,0,1,0)
a <- c(1,1,1,2,2,2)
b <- c(1,2,3,1,2,3)
X <. cbind(x,a,b)
X <- cbind(x,a,b)
X
y <- cbind(y)
y
y <- cbind(y)
y~x
y~x
rep <- y~x
rep
fit <- lm(y~x)
fit
mm <- model.matrix(~x)
mm
MM <- model.matrix(~x)
MM
MM <- model.matrix(~x-1)
MM
MM <- model.matrix(~x+a)
MM
MM <- model.matrix(~a-1)
MM
MM <- model.matrix(~a+b)
MM
library(MASS)
bivn <- mvrnorm(1000, mu = c(0, 0), Sigma = matrix(c(1, .5, .5, 1), 2))
# now we do a kernel density estimate
bivn.kde <- kde2d(bivn[,1], bivn[,2], n = 50)
# now plot your results
contour(bivn.kde)
image(bivn.kde)
persp(bivn.kde, phi = 45, theta = 30)
# fancy contour with image
image(bivn.kde); contour(bivn.kde, add = T)
# fancy perspective
persp(bivn.kde, phi = 45, theta = 30, shade = .1, border = NA)
matrix(c(1, 0, 0, 1), 2))
matrix(c(1, 0, 0, 1), 2)
matrix(c(1, 2, 3, 4), 2)
bivn <- mvrnorm(1000, mu = c(0, 0), Sigma = matrix(c(1, 0, 0, 1), 2))
persp(bivn, phi = 45, theta = 30)
bivn <- mvrnorm(1000, mu = c(0, 0), Sigma = matrix(c(1, 0, 0, 1), 2))
# now we do a kernel density estimate
bivn.kde <- kde2d(bivn[,1], bivn[,2], n = 50)
# now plot your results
contour(bivn.kde)
image(bivn.kde)
persp(bivn.kde, phi = 45, theta = 30)
swiss
?swiss
pairs(swiss)
cor(swiss)
cor(swiss)  # correlation matrix
boxplot(swiss)
plot(swiss$Examination, swiss$Fertility)
plot(swiss$Infant.Mortality, swiss$Fertility)
fit = lm(Fertility~Examination+Infant.Mortality, data=swiss)  # explain Fertility using Examination and Infant.Mortality
summary(fit)
summary(fit)
confint(fit)  #  buid confidence intervals
model.matrix(fit)  # we get the X matrix
fit = lm(Fertility~Examination+Infant.Mortality, data=swiss)  # explain Fertility using Examination and Infant.Mortality
summary(fit)
# les stars donnent un avis about the significance of the estimate
confint(fit)  #  buid confidence intervals
model.matrix(fit)  # we get the X matrix
plot(swiss$Examination, rstandard(fit))
plot(swiss£Infant.Mortality, rstandard(fit))
plot(swiss$Infant.Mortality, rstandard(fit))
?rstandard
plot(fitted(fit), rstandard(fit))  # fitted() gives the y-hat, rstandard() gives the standardized residuals
plot(fitted(fit), rstandard(fit),ylim=c(-3,3), xlab="fitted values", ylab="standardized residuals")
qqnorm(rstandard(fit))
qqline(rstandard(fit))
plot(cooks.distance(fit))
p <- dim(model.matrix(fit))[2]
n <- dim(model.matrix(fit))[1]
abline(8/(n-2*p),0)
identify(cooks.distance(fit),labels=rownames(swiss))
plot(hatvalues(fit))
abline(2*p/n,0)
identify(hatvalues(fit), labels=rownames(swiss))
plot(swiss$Examination, swiss$Fertility)
text(swiss$Examination[19], swiss$Fertility[19], rownames(swiss)[19])
plot(swiss$Infant.Mortality, swiss$Fertility)
text(swiss$Infant.Mortality[19], swiss$Fertility[19], rownames(swiss)[19])
?hatvalues
load('cars.RData')
setwd("~/Google Drive/EPFL/Bachelor 7/ModLin/Practicals/p2_remote/LinearModelsEPFL")
load('cars.RData')
# the response y : 100 / City MPG
hundredOverMPG <- rep(100,82) / cars$CityMPG
# the variables
weights <- cars$Weight
HPOverWeight <- cars$Horsepower / cars$Weight
# premier model dans l ordre Y = b0 + X1*b1 + X2*b2
fit1 = lm(hundredOverMPG ~ weights + HPOverWeight)
# deuxième model model dans l ordre Y = b0 + X2*b2 + X1*b1
fit2 = lm(hundredOverMPG ~ HPOverWeight + weights)
# Creation des tables d'ANOVA
anova(fit1)
anova(fit2)
install.packages(xtable);
install.packages("xtable");
newData <- cars[ ,11:26]
FullFit <- lm(y ~ ., data = newData)
summary(FullFit)
FullFit <- lm(hundredOverMPG ~ ., data = newData)
summary(FullFit)
summaryFullFit <- xtable(summary(FullFit))
print(summaryFullFit)
install.packages("xtable");
library(xtable)
summaryFullFit <- xtable(summary(FullFit))
print(summaryFullFit)
vif(FullFit)
install.packages("VIF")
library(VIF)
vif(FullFit)
FullFit
FullFit
vif(FullFit)
library(VIF)
library(vif)
FullFit <- lm(hundredOverMPG ~ ., data = newData)
summary(FullFit)
# Latex table
summaryFullFit <- xtable(summary(FullFit))
print(summaryFullFit)
# VIF of the full model
library(VIF)
vif(FullFit)
library(car)
install.packages("car")
library(car)
library(car)
vif(FullFit)
f1 <- lm(hundredOverMPG ~ ., data = newData)
m1.backward <- step(f1, direction = "backward")
f2 <- lm(hundredOverMPG ~ 1, data = newData)
my.scope <- formula(newData)
m2.forward <- step(f2, scope = my.scope, direction = "forward", data = newData)
f1 <- lm(hundredOverMPG ~ ., data = newData)
f1.backward <- step(f1, direction = "backward")
summary(f1.backward)
f3 <- lm(hundredOverMPG ~ ., data = newData) # Fitting model using all the covariates
f3.backward <- step(f3, direction = "backward", k=log(length(perf)))
f3.backward <- step(f3, direction = "backward", k=log(length(newData)))
# BIC, Forward
f4 <- lm(hundredOverMPG ~ 1, data = newData) # Fitting the model with only one varialbe, the 1 column
my.scope <- formula(newData)
f4.forward <- step(f4, scope = my.scope, direction = "forward", data = newData, k=log(length(newData)))
summary(f2.forward)
# BIC, Backward
f3 <- lm(hundredOverMPG ~ ., data = newData) # Fitting model using all the covariates
f3.backward <- step(f3, direction = "backward", k=log(length(newData)))
summary(f4.backward)
summary(f3.backward)
# BIC, Forward
f4 <- lm(hundredOverMPG ~ 1, data = newData) # Fitting the model with only one varialbe, the 1 column
my.scope <- formula(newData)
f4.forward <- step(f4, scope = my.scope, direction = "forward", data = newData, k=log(length(newData)))
summary(f4.forward)
vif(f1.backward)
vif(f2.forward)
summary(f2.forward)
vif(f2.forward)
f2 <- lm(hundredOverMPG ~ 1, data = newData)
my.scope <- formula(newData)
f2.forward <- step(f2, scope = my.scope, direction = "forward", data = newData)
summary(f2.forward)
vif(f2.forward)
summary(f4.forward)
vif(f4.forward)
newData <- cars[ ,11:26]
newData
head(newData)
newData2 = cars[,-c(1,2,3,4,5,6,7,8,9,10,17,19,20,21,22)]
head(newData2)
